## Graph Middleware integration using Subgraphs

Working with the data stored on chain and on IPFS is not trivial. In the SettleMint platform we provide you with a middleware solution that allows you to index and query this data easily and efficiently.

At the hard of the middleware solution is the indexer module from [The Graph](https://thegraph.com/) that you can run on your own EVM compatible nodes (both public and consortium networks), your own IPFS node, and fully preconfigured, managed and integrated with the smart contract sets.

We provide two indexing libraries, one by the OpenZeppelin team for all the common smart contracts in their smart contract library, and one by the SettleMint team to extend the capabilities of the OpenZeppelin one, and to provide indexing of the specifics the SettleMint smart contract sets.

The OpenZeppelin set contains the following indexing modules:

- accesscontrol
- erc1155
- erc1967upgrade
- erc20
- erc721
- governor
- ownable
- pausable
- timelock
- voting

This set contains the following custom indexing modules for you to use or modify:

- erc721ipfs: to extend the erc721 from openzeppelin to index IPFS metadata of your erc721 tokens
- erc721freezable: allows you to update all indexed metadata when the tokens are frozen (often right after reveals)
- crowdsale: to index the metadata of the crowdsale smart contract
- forwarder: indexes event from the meta transaction forwarder
- statemachinemetadata: indexes state machine data
- vestingvault: indexes vesting vault data (used in the crowdsale sets)
- vesting wallet: indexes vesting wallet data (used in the crowdsale sets)

Lastly, in this folder, you can create your own modules for any other data you want to index, or for custom smart contracts not part of the default sets.

### How to use the indexing modules

Inside the root of this smart contract set, you will find a file called `subgraph.config.template.json` that contains the raw configuration. The important section is the datasources section.

Here we defined the smart contracts with their name (the name of the artifact created in the 'deployments' folder when running the `deploy` task) and in the modules array all the indexing modules we want to activate for this smart contract.

You will notice the startblock and address to be 0. These will be filled in using the `graph:config` task based on the hardhat deployments.

So, to start, tweak the `subgraph.config.template.json` file to your liking, and run the `graph:config` task. This will generate `subgraph.config.json` for the next steps.

The following tasks need to be run afterwards:

- `graph:compile` -> uses `subgraph.config.json` to generate the graphql schema and subgraph configuration
- `graph:codegen` -> generates the AssemblyScript types for your contracts ABI based on the output of `graph:compile`
- `graph:build` -> compiles the WASM files based on the outpts generated by `graph:codegen`
- `graph:deploy` -> deploys the WASM files to IPFS and updates the middleware to start or update the indexing

> if you just want to do it all in one go, use `graph:all` which does all these tasks in the right order.

Indexing can take a while, but in seconds you can query the middleware for your data.

### Writing your own indexing modules

To make a module you need the following:

- Primitives to generate a graphql schema: `subgraph/datasource/x.gql.json` -> In order to allow composability, the schema are not defined in the graphql format but rather in a dedicated json format which is can be assembled and compiled to graphql.
- Template to generate a subgraph manifest: `subgraph/datasource/x.yaml` -> This file lists all the events that the datasources should listen to, and links that to the corresponding indexing logic.
- Indexing logic: `subgraph/datasources/x.ts` and (optionally) `subgraph/fetch/x.ts` -> This is the core logic that processes the events and to index the onchain activity.

To learn more, check out <https://github.com/OpenZeppelin/openzeppelin-subgraphs>
